bignum operator+(const bignum &b1, const bignum &b2){
	bignum nuevo ;
	if(b1.sign != b2.sign) {
		if(b1.sign == true) {
			bignum _b1(b1);
			_b1.sign = !b1.sign;
			nuevo = b2-_b1;
		}
		else {
			bignum _b2(b2);
			_b2.sign = !b2.sign;
			nuevo = b1-_b2;
		}
	}
	else {
		bool sign = b1.sign; 
		
		size_t size = (b1.size >= b2.size)?b1.size:b2.size;
		unsigned short *digits = new unsigned short[size];
		
		// Inicialmente el carry es 0
		unsigned short carry = 0;

		// Calculo la suma
		for (size_t i = size; i >= 1; i--) {
			// Cargo el resto
			digits[i-1] = (b1.digits[i-1] + b2.digits[i-1] + carry)%10;
			// Me quedo con el carry para el siguiente
			carry = (b1.digits[i-1] + b2.digits[i-1] + carry)/10;
		}

		// Si el carry es 1
		if(carry == 1) {
			unsigned short *digits2 = new unsigned short[size+1];
			// Desplazo
			for (int i = size; i >= 1; i--) {
				digits2[i] = digits[i-1];
			}
			// y Agrego el carry
			digits2[0] = carry;
			// Vuelvo al original
			digits = digits2;
		}

		// Armo el bignum y lo devuelvo
		nuevo = bignum(sign,size,digits);
	}
	return nuevo;
}